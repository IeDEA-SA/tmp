#' tbls_check UI Function
#'
#' @description Module for creating panels for selected tables
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd
#'
#' @importFrom shiny NS tagList
#' @importFrom bslib navset_underline
#' @importFrom dplyr anti_join if_else pull filter
#' @importFrom rlang is_empty
#' @importFrom purrr pwalk map
mod_tbl_tabs_ui <- function(id) {
  ns <- NS(id)
  navset_underline(id = ns("tab"))
}

#' Dynamic Table Tabs Module Server
#'
#' This module server function dynamically manages tabs in a Shiny application
#' based on the provided list of tables and a hash code generated by the corresponding
#' source file metadata. It adds or removes tabs based on the tables' existence
#' and their hash, and it handles the namespace for UI components by generating random
#' table ids. The table tabs metadata (source file info hash, table name, random table id)
#' are kept into a lookup table stored in `session$userData` to monitor the state
#' of the selected tables, avoid component drilling, and update UI elements.
#'
#' @param tbls Reactive. List of previous and current tibbles for each selected
#' table. Output of the `mod_read_tbls()` module.
#'
#' @return Reactive. A list of valid tables, processed to clean names and subse
#' to valid shared variables where appropriate.
#' @noRd
#'
mod_tbl_tabs_server <- function(id, tbls) {
  stopifnot(is.reactive(tbls))
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    checks <- reactive({
      map(tbls(), ~ check_tbls(.x))
    })

    clean_tbls <- reactiveValues()

    observe({
      req(tbls())
      selected_sources_lookup <- get_tbl_tabs_lookup(
        tbls(),
        session$userData$tab_list
      )

      log_debug("Table tabs meta:")
      log_debug("{selected_sources_lookup}")
      remove_tabs <- session$userData$tab_list %>%
        anti_join(selected_sources_lookup, by = "source_hash")

      add_tabs <- selected_sources_lookup %>%
        anti_join(session$userData$tab_list, by = "source_hash")

      # REMOVE TABS ----
      if (isTRUE(nrow(remove_tabs) > 0)) {
        purrr::walk2(
          .x = remove_tabs$tbl_name,
          .y = remove_tabs$tab_id,
          ~ {
            remove_tbl_tab(.x, .y, ns, input, output, session)
            remove_rv(clean_tbls, .y)
          }
        )
        log_debug("clean_tabs after removal: {names(clean_tbls)}")
      }

      # ADD TABS ----
      if (isTRUE(nrow(add_tabs) > 0)) {
        purrr::walk2(
          .x = add_tabs$tbl_name,
          .y = add_tabs$tab_id,
          ~ {
            tbl_name <- .x
            tab_id <- .y
            tbl_valid <- checks()[[tbl_name]]$valid
            tbl_valid_cols <- checks()[[tbl_name]]$check_coltypes$valid_cols

            clean_tbls[[tab_id]] <- mod_display_check_server(
              id = tab_id,
              tbl = tbls()[[tbl_name]],
              tbl_name = tbl_name,
              check = checks()[[tbl_name]]
            )

            comb_tbl <- reactive({
              log_debug("Clean tables combined for table: {tbl_name}")
              combine_tbls(
                current_tbl = clean_tbls[[tab_id]]()$current,
                previous_tbl = clean_tbls[[tab_id]]()$previous,
                tbl_name = tbl_name
              )
            })

            tbl_tab_ui(
              tbl_name, tab_id, ns, tbl_valid_cols, tbl_valid, clean_tbls,
              session
            )
            tbl_tab_pk(tbl_name, comb_tbl, session, tbl_valid_cols)
            tbl_tab_server(tab_id, tbl_name, comb_tbl)
          }
        )
      }
      # Add Summary Tab ----
      summary_tab(ns, input, output, session)
      session$userData$tab_list <- selected_sources_lookup
    }) %>%
      bindEvent(tbls())
  })
}
