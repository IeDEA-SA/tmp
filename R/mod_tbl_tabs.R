#' tbls_check UI Function
#'
#' @description Module for creating panels for selected tables
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd
#'
#' @importFrom shiny NS tagList
#' @importFrom bslib navset_underline
#' @importFrom tibble enframe
#' @importFrom dplyr anti_join if_else
#' @importFrom rlang is_empty
#' @importFrom purrr pwalk map walk2
mod_tbl_tabs_ui <- function(id) {
  ns <- NS(id)
  navset_underline(id = ns("tab"))
}

#' Dynamic Table Tabs Module Server
#'
#' This module server function dynamically manages tabs in a Shiny application
#' based on the provided list of tables and a hash code generated by the corresponding
#' source file metadata. It adds or removes tabs based on the tables' existence
#' and their hash, and it handles the namespace for UI components. The function
#' uses `session$userData` to monitor the state of the selected tables, avoid
#' component drilling, and update UI elements.
#'
#' @param tbls Reactive. List of previous and current tibbles for each selected
#' table. Output of the `mod_read_tbls()` module.
#'
#' @return Reactive. A list of valid tables, processed to clean names and subse
#' to valid shared variables where appropriate.
#' @noRd
#'
mod_tbl_tabs_server <- function(id, tbls) {
  stopifnot(is.reactive(tbls))
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    checks <- reactive({
      map(tbls(), ~ check_tbls(.x))
    })

    clean_tbls <- reactiveValues()

    observe({
      req(tbls())

      selected_sources_lookup <- get_tbl_hash_lookup(tbls()) %>%
        enframe("source_hash", "tbl_name") %>%
        left_join(session$userData$tab_list, by = c("source_hash", "tbl_name")) %>%
        rowwise() %>%
        mutate(
          tab_id = if_else(is.na(tab_id), make_uuid(tbl_name), tab_id)
        )

      remove_tabs <- session$userData$tab_list %>%
        anti_join(selected_sources_lookup, by = "source_hash")

      add_tabs <- selected_sources_lookup %>%
        anti_join(session$userData$tab_list, by = "source_hash")

      selected_tab <- input$tab

      if (isTRUE(nrow(remove_tabs) > 0)) {
        pwalk(remove_tabs, function(source_hash, tbl_name, tab_id) {
          log_debug("remove tab {tbl_name}")
          tbl_name_ns <- ns(tbl_name)

          removeUI(
            selector = "div:has(> '#shiny-modal')",
            multiple = TRUE
          )

          removeTab("tab", tbl_name_ns)
          remove_shiny_inputs(tbl_name_ns, input, parent_id = sprintf("%s-", ns(NULL)))
          remove_shiny_outputs(tbl_name_ns, output, parent_id = sprintf("%s-", ns(NULL)))

          session$userData$plots[[tbl_name]] <- NULL
          session$userData$add_plot_observers[[tbl_name]]$destroy()
        })
      }

      pwalk(add_tabs, function(source_hash, tbl_name, tab_id) {
        log_debug("adding tab {tbl_name}")
        tab_index <- which(names(tbls()) %in% tbl_name)
        tab_panel <- tabPanel(
          title = tbl_name,
          mod_display_check_ui(ns(tbl_name)),
          mod_tbl_plots_ui(ns(tbl_name)),
          value = ns(tbl_name),
          icon = if (checks()[[tbl_name]]$valid) icon("check") else icon("x")
        )
        if(tab_index == 1) {
          prependTab(
            inputId = "tab",
            tab_panel,
            select = selected_tab
          )
        } else {
          insertTab(
            inputId = "tab",
            target = names(tbls())[tab_index - 1] %>% ns(),
            position = "after",
            tab_panel,
            select = selected_tab
          )
        }

        clean_tbls[[tbl_name]] <- mod_display_check_server(
          id = tbl_name,
          tbl = tbls()[[tbl_name]],
          tbl_name = tbl_name,
          check = checks()[[tbl_name]]
        )

        mod_tbl_plots_server(
          id = tbl_name,
          tbl = clean_tbls[[tbl_name]],
          tbl_name = tbl_name
        )
      })
      session$userData$tab_list <- selected_sources_lookup
    }) %>%
      bindEvent(tbls())
  })
}
