#' tbls_check UI Function
#'
#' @description Module for creating panels for selected tables
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd
#'
#' @importFrom shiny NS tagList
#' @importFrom bslib navset_underline
#' @importFrom dplyr anti_join if_else pull filter
#' @importFrom rlang is_empty
#' @importFrom purrr pwalk map
mod_tbl_tabs_ui <- function(id) {
  ns <- NS(id)
  navset_underline(id = ns("tab"))
}

#' Dynamic Table Tabs Module Server
#'
#' This module server function dynamically manages tabs in a Shiny application
#' based on the provided list of tables and a hash code generated by the corresponding
#' source file metadata. It adds or removes tabs based on the tables' existence
#' and their hash, and it handles the namespace for UI components by generating random
#' table ids. The table tabs metadata (source file info hash, table name, random table id)
#' are kept into a lookup table stored in `session$userData` to monitor the state
#' of the selected tables, avoid component drilling, and update UI elements.
#'
#' @param tbls Reactive. List of previous and current tibbles for each selected
#' table. Output of the `mod_read_tbls()` module.
#'
#' @return Reactive. A list of valid tables, processed to clean names and subse
#' to valid shared variables where appropriate.
#' @noRd
#'
mod_tbl_tabs_server <- function(id, tbls) {
  stopifnot(is.reactive(tbls))
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    checks <- reactive({
      map(tbls(), ~ check_tbls(.x))
    })

    clean_tbls <- reactiveValues()

    observe({
      req(tbls())

      selected_sources_lookup <- get_tbl_tabs_lookup(
        tbls(),
        session$userData$tab_list
      )

      log_debug("Table tabs meta:")
      log_debug("{selected_sources_lookup}")
      remove_tabs <- session$userData$tab_list %>%
        anti_join(selected_sources_lookup, by = "source_hash")

      add_tabs <- selected_sources_lookup %>%
        anti_join(session$userData$tab_list, by = "source_hash")

      if (isTRUE(nrow(remove_tabs) > 0)) {
        pwalk(remove_tabs, function(source_hash, tbl_name, tab_id) {
          log_debug("remove tab {tbl_name}")
          tbl_id_ns <- ns(tab_id)

          removeUI(
            selector = "div:has(> '#shiny-modal')",
            multiple = TRUE
          )

          removeTab("tab", tbl_id_ns)
          remove_shiny_inputs(tbl_id_ns, input, parent_id = sprintf("%s-", ns(NULL)))
          remove_shiny_outputs(tbl_id_ns, output, parent_id = sprintf("%s-", ns(NULL)))

          session$userData$plots[[tbl_name]] <- NULL
          session$userData$add_plot_observers[[tab_id]]$destroy()
          if (tbl_name == session$userData$pk_tbl_name) {
            log_debug("Removing pk_tbl with primary key info from {tbl_name}.")
            session$userData$pk_tbl <- NULL
            showNotification(
              glue::glue("Table {tbl_name} removed as source of primary key info."),
              type = "default"
            )
          }
        })
      }

      pwalk(add_tabs, function(source_hash, tbl_name, tab_id) {
        log_debug("adding tab {tbl_name}")
        tab_index <- which(names(tbls()) %in% tbl_name)
        tab_icon <- if (checks()[[tbl_name]]$valid) {
          if (tbl_name == session$userData$pk_tbl_name) {
            icon("key")
          } else {
            icon("check")
          }
        } else {
          icon("x")
        }
        tab_panel <- tabPanel(
          title = tbl_name,
          mod_pk_column_ui(ns(tab_id)),
          mod_display_check_ui(ns(tab_id)),
          mod_tbl_plots_ui(ns(tab_id)),
          value = ns(tab_id),
          icon = tab_icon
        )
        if (tab_index == 1) {
          log_debug("Prepend as first tab")
          prependTab(
            inputId = "tab",
            tab_panel,
            select = FALSE
          )
        } else {
          target_tab <- selected_sources_lookup %>%
            filter(tbl_name == names(tbls())[tab_index - 1]) %>%
            pull(tab_id) %>%
            ns()

          log_debug("Insert as tab after {target_tab}")
          shiny::insertTab(
            inputId = "tab",
            target = target_tab,
            position = "after",
            tab_panel,
            select = FALSE
          )
        }

        clean_tbls[[tab_id]] <- mod_display_check_server(
          id = tab_id,
          tbl = tbls()[[tbl_name]],
          tbl_name = tbl_name,
          check = checks()[[tbl_name]]
        )

        if (tbl_name == session$userData$pk_tbl_name) {
          if (session$userData$pk_col %in% names(tbls()[[tbl_name]]$current)) {
            log_debug("Subsetting {tbl_name} for primary key info.")
            session$userData$pk_tbl <- subset_pk_tbl_cols(
              tbl = combine_tbls(
                current_tbl = tbls()[[tbl_name]]$current,
                previous_tbl = tbls()[[tbl_name]]$previous,
                tbl_name = tbl_name
              ),
              pk_col = session$userData$pk_col
            )
            showNotification(
              glue::glue("Table {tbl_name} set as source of primary key info."),
              type = "default"
            )
            print(session$userData$pk_tbl)
          } else {
            log_debug("Failed to subset {tbl_name} for primary key info.
                      pk_col {session$userData$pk_col} missing.")
            showNotification(
              glue::glue(
                "Expected primary key column '{session$userData$pk_col}' not found
                in primary key table. Please check data or use `pk_col` argument
                in `run_app` to re-configure primary key column."
              ),
              duration = NULL,
              type = "error"
            )
          }
        }
        mod_pk_column_server(id = tab_id,
                             comb_tbl = combine_tbls(
                               current_tbl = tbls()[[tbl_name]]$current,
                               previous_tbl = tbls()[[tbl_name]]$previous,
                               tbl_name = tbl_name
                             ),
                             tbl_name = tbl_name)
        mod_tbl_plots_server(
          id = tab_id,
          tbl = clean_tbls[[tab_id]],
          tbl_name = tbl_name
        )
      })
      log_debug("Append summary tab at the end of the tab list.")
      summary_panel <- tabPanel(
        title = "summary",
        value = ns("summary"),
        icon = icon("rectangle-list")
      )
      appendTab(
        inputId = "tab",
        summary_panel,
        select = FALSE
      )
      session$userData$tab_list <- selected_sources_lookup
    }) %>%
      bindEvent(tbls())
  })
}
